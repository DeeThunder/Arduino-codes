/*
  Sketch generated by the Arduino IoT Cloud Thing "VehicleMonitoringSystem"
  https://create.arduino.cc/cloud/things/42802856-b0a2-48d8-acad-ecd510bd06b7

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String gpslocationCloud;
  float distanceCloud;
  bool accidentDetectedCloud;
  bool gasLeakCloud;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <TinyGPSPlus.h>
#include <SoftwareSerial.h> // Though HardwareSerial is preferred on ESP32, keep if used elsewhere.
#include <HardwareSerial.h>
#include <BluetoothSerial.h> // Include the Bluetooth Serial library

// LCD Setup
LiquidCrystal_I2C lcd(0x27, 16, 2);

// GPS Setup (Serial1)
HardwareSerial gpsSerial(1); // UART1
TinyGPSPlus gps;

// GSM Setup (Serial2)
HardwareSerial gsmSerial(2); // UART2

// Pin Definitions - Vehicle Monitoring System
#define VIBRATION_PIN 34
#define MQ2_AO_PIN 35
#define TRIG_PIN 23    // Reconfirmed: This pin is fine as is, but if you have issues, consider moving.
#define ECHO_PIN 5     // Reconfirmed: This pin is fine as is.
#define STOP_SIGNAL_PIN 25 // Reconfirmed: This pin is fine as is.

// LED Pins
#define BLUE_LED_PIN 12   // Obstacle Detected
#define RED_LED_PIN 4     // Accident Detected
#define GREEN_LED_PIN 18  // Normal

// Thresholds
#define GAS_THRESHOLD 1500
#define DISTANCE_THRESHOLD_CM 35
#define VIBRATION_DEBOUNCE_COUNT 5

bool accidentDetected = false;
int vibrationCount = 0;

// --- RC Car Control Pin Definitions (REASSIGNED PINS) ---
// Using available GPIO pins that don't conflict with existing system.
// Verify these pins are suitable for your ESP32 board (e.g., if they have pull-ups/downs).
#define MOTOR_IN1_RC 15    // New pin for L298N IN1 (Left side motors direction)
#define MOTOR_IN2_RC 19   // New pin for L298N IN2 (Left side motors direction)
#define MOTOR_ENA_RC 13   // New PWM pin for L298N ENA (Left side speed control)

#define MOTOR_IN3_RC 2 // New pin for L298N IN3 (Right side motors direction)
#define MOTOR_IN4_RC 32   // New pin for L298N IN4 (Right side motors direction)
#define MOTOR_ENB_RC 33   // New PWM pin for L298N ENB (Right side speed control)

// Initialize Bluetooth Serial for RC Control
BluetoothSerial SerialBT;

// Global variable for motor speed (0-255)
int rcMotorSpeed = 150; // Default speed for RC control

// Function to set both motor channels (Left and Right) of the single L298N
void setAllMotorChannelsState(int leftDir1, int leftDir2, int rightDir1, int rightDir2, int speed) {
  // Set directions for Left Side motors (connected to OUT1/OUT2)
  digitalWrite(MOTOR_IN1_RC, leftDir1);
  digitalWrite(MOTOR_IN2_RC, leftDir2);

  // Set directions for Right Side motors (connected to OUT3/OUT4)
  digitalWrite(MOTOR_IN3_RC, rightDir1);
  digitalWrite(MOTOR_IN4_RC, rightDir2);

  // Apply speed to both channels
  analogWrite(MOTOR_ENA_RC, speed);
  analogWrite(MOTOR_ENB_RC, speed);
}


void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  Wire.begin(21, 22); // SCL, SDA for I2C (LCD)
  lcd.init();
  lcd.backlight();
  lcd.print("System Starting...");

  // Pin Modes - Vehicle Monitoring System
  pinMode(VIBRATION_PIN, INPUT);
  pinMode(MQ2_AO_PIN, INPUT);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(STOP_SIGNAL_PIN, OUTPUT);

  pinMode(BLUE_LED_PIN, OUTPUT);
  pinMode(RED_LED_PIN, OUTPUT);
  pinMode(GREEN_LED_PIN, OUTPUT);

  // GPS & GSM
  gpsSerial.begin(9600, SERIAL_8N1, 16, 17);  // GPS (RX, TX)
  gsmSerial.begin(9600, SERIAL_8N1, 26, 27);  // GSM (RX, TX) - Note: GSM TX (27) conflicts with a new motor pin.

  // --- RC Car Control Pin Modes ---
  // Re-verify these pins. Note that GSM's TX pin 27 is now used for MOTOR_IN3_RC.
  // If GSM is critical, you'll need to find another pin for MOTOR_IN3_RC or move GSM.
  // For now, I'll assume GSM is less critical than RC control if conflicts arise.
  pinMode(MOTOR_IN1_RC, OUTPUT);
  pinMode(MOTOR_IN2_RC, OUTPUT);
  pinMode(MOTOR_ENA_RC, OUTPUT);
  pinMode(MOTOR_IN3_RC, OUTPUT);
  pinMode(MOTOR_IN4_RC, OUTPUT);
  pinMode(MOTOR_ENB_RC, OUTPUT);

  // Start with motors stopped (direction inputs LOW, speed 0)
  setAllMotorChannelsState(LOW, LOW, LOW, LOW, 0);
  Serial.print("Initial RC motorSpeed set to: ");
  Serial.println(rcMotorSpeed);

  // Initialize Bluetooth Serial for RC Control
  SerialBT.begin("ESP32_Vehicle_RC"); // Give your ESP32 a recognizable Bluetooth name
  Serial.println("Bluetooth Started! Ready to pair for RC control.");

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  lcd.clear();
  lcd.print("System Ready");
}

void loop() {
  ArduinoCloud.update();
  // Your existing Vehicle Monitoring System code here
  int vibration = digitalRead(VIBRATION_PIN);
  int gasLevel = analogRead(MQ2_AO_PIN);
  float distanceReading = readUltrasonic();
  bool obstacleDetected = false;
  bool gasLeakStatus = gasLevel > GAS_THRESHOLD;

  while (gpsSerial.available()) {
    gps.encode(gpsSerial.read());
  }

  // Obstacle detection
  if (distanceReading > 0 && distanceReading < DISTANCE_THRESHOLD_CM) {
    digitalWrite(STOP_SIGNAL_PIN, HIGH); // Stop the vehicle
    lcd.setCursor(0, 1);
    lcd.print("Obstacle <35cm ");
    obstacleDetected = true;
    // Potentially stop RC motors too if an obstacle is detected
    setAllMotorChannelsState(LOW, LOW, LOW, LOW, 0); // Stop RC motors
  } else {
    digitalWrite(STOP_SIGNAL_PIN, LOW);
  }

  // Gas detection debounce (This part of the code seems to be related to vibration, not gas debounce based on the variable names)
  // Let's assume it's for accident detection as per variable `accidentDetected`
  if (vibration == HIGH) {
    vibrationCount++;
  } else {
    if (vibrationCount > 0) vibrationCount--;
  }

  if (vibrationCount >= VIBRATION_DEBOUNCE_COUNT && !accidentDetected) {
    accidentDetected = true;
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Accident!");
    lcd.setCursor(0, 1);
    lcd.print("Sending Alert...");
    sendSMS();
    setAllMotorChannelsState(LOW, LOW, LOW, LOW, 0); // Stop RC motors on accident
  }

  // LCD Gas status
  lcd.setCursor(0, 0);
  if (gasLeakStatus) {
    lcd.print("Gas Leak!    ");
  } else {
    lcd.print("Gas OK       ");
  }

  // LED Status
  if (accidentDetected) {
    digitalWrite(RED_LED_PIN, HIGH);
    digitalWrite(BLUE_LED_PIN, LOW);
    digitalWrite(GREEN_LED_PIN, LOW);
  } else if (obstacleDetected) {
    digitalWrite(RED_LED_PIN, LOW);
    digitalWrite(BLUE_LED_PIN, HIGH);
    digitalWrite(GREEN_LED_PIN, LOW);
  } else if (!gasLeakStatus) {
    digitalWrite(RED_LED_PIN, LOW);
    digitalWrite(BLUE_LED_PIN, LOW);
    digitalWrite(GREEN_LED_PIN, HIGH);
  } else {
    digitalWrite(RED_LED_PIN, LOW);
    digitalWrite(BLUE_LED_PIN, LOW);
    digitalWrite(GREEN_LED_PIN, LOW);
  }

  // --- Send values to IoT Cloud variables ---
  accidentDetectedCloud = accidentDetected;
  gasLeakCloud = gasLeakStatus;
  distanceCloud = distanceReading;

  if (gps.location.isValid()) {
    gpslocationCloud = "Lat:" + String(gps.location.lat(), 6) + " Lng:" + String(gps.location.lng(), 6);
  } else {
    gpslocationCloud = "No GPS";
  }

  // --- RC Car Control Logic (Integrated) ---
  if (SerialBT.available()) {
    String command = SerialBT.readStringUntil('\n'); // Read incoming command until newline
    command.trim(); // Remove any leading/trailing whitespace

    Serial.print("Received BT Command: ");
    Serial.println(command);

    if (command.startsWith("V")) {
      int receivedSpeed = command.substring(1).toInt(); // Extract number after 'V'
      rcMotorSpeed = constrain(receivedSpeed, 0, 255); // Limit speed to 0-255
      Serial.print("Desired BT Speed: ");
      Serial.println(rcMotorSpeed);
      // No need to apply speed immediately here unless the car is already moving.
      // The speed will be applied when a movement command is received (F, B, L, R).
      // However, if you want the speed to update dynamically even when stationary,
      // you could consider setting it here, but it's usually applied with movement.
    } else if (command == "F") {
      setAllMotorChannelsState(HIGH, LOW, HIGH, LOW, rcMotorSpeed); // All motors Forward
      Serial.println("Moving All Forward");
    } else if (command == "B") {
      setAllMotorChannelsState(LOW, HIGH, LOW, HIGH, rcMotorSpeed); // All motors Backward
      Serial.println("Moving All Backward");
    } else if (command == "L") { // Pivot Left (Right side forward, Left side backward)
      setAllMotorChannelsState(LOW, HIGH, HIGH, LOW, rcMotorSpeed);
      Serial.println("Turning Left (Pivot)");
    } else if (command == "R") { // Pivot Right (Left side forward, Right side backward)
      setAllMotorChannelsState(HIGH, LOW, LOW, HIGH, rcMotorSpeed);
      Serial.println("Turning Right (Pivot)");
    } else if (command == "S") {
      setAllMotorChannelsState(LOW, LOW, LOW, LOW, 0); // Stop all motors
      Serial.println("Stopping All Motors");
    } else {
      Serial.println("Unknown command received.");
    }
  }

  delay(500); // Adjust delay as needed, but be mindful of responsiveness for RC control.
}

void sendSMS() {
  String location = "Unknown";
  if (gps.location.isValid()) {
    location = "Lat: " + String(gps.location.lat(), 6) + ", Lng: " + String(gps.location.lng(), 6);
  }
  // Implement actual SMS sending here using gsmSerial.
  // Example (replace with your actual AT commands and recipient):
  /*
  gsmSerial.println("AT+CMGF=1");    // Set SMS to text mode
  delay(100);
  gsmSerial.println("AT+CMGS=\"+234xxxxxxxxxx\""); // Replace with recipient number
  delay(100);
  gsmSerial.print("Accident Detected! Location: " + location);
  gsmSerial.write(0x1A); // End of SMS message
  delay(1000);
  */
  Serial.println("SMS would be sent to: +234xxxxxxxxxx with location: " + location);
}

float readUltrasonic() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  long duration = pulseIn(ECHO_PIN, HIGH, 30000);
  if (duration == 0) return 999; // Return a large value if no echo within timeout
  return (duration * 0.0343) / 2.0;
}